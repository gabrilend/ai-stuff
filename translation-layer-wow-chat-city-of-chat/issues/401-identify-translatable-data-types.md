# 104 - Identify Translatable Data Types

## Status
- Phase: 1
- Priority: Medium
- Dependencies: 101, 102, 103

---

## Current Behavior

The mapping matrix (103) will show what CAN be mapped, but does not
specify the actual Lua data structures that will carry translated data
through the system.

---

## Intended Behavior

Define the internal data types used by the translation layer:

1. **TranslatedPacket** - The universal container for cross-game data
2. **CharacterState** - Unified character representation
3. **CombatEvent** - Unified damage/heal/buff event
4. **WorldPosition** - Unified coordinate system
5. **ChatMessage** - Unified communication event

These types abstract away game-specific details so the LLM and
narrative systems can work with clean, predictable data.

---

## Suggested Implementation Steps

1. Design TranslatedPacket structure:
   ```lua
   -- Universal packet wrapper
   TranslatedPacket = {
     source_game = "wow" | "coh",
     target_game = "coh" | "wow",
     packet_type = "movement" | "combat" | "chat" | ...,
     timestamp = <unix_ms>,
     original_data = <raw_bytes>,
     translated_data = <table>,
     confidence = 0.0 - 1.0,  -- How reliable is this translation?
     narrative_needed = true | false,
   }
   ```

2. Design CharacterState for unified character view:
   ```lua
   CharacterState = {
     id = <unique_id>,
     name = <string>,
     -- Normalized stats (0-100 scale)
     health = <percent>,
     resource = <percent>,  -- mana/endurance/rage
     level = <number>,
     position = WorldPosition,
     -- Source-specific data preserved for fallback
     wow_data = <table> | nil,
     coh_data = <table> | nil,
   }
   ```

3. Design CombatEvent for ability/damage translation:
   ```lua
   CombatEvent = {
     actor = <character_id>,
     target = <character_id>,
     action_type = "damage" | "heal" | "buff" | "debuff" | "cc",
     amount = <number>,
     -- Semantic ability info for narrative
     ability_name = <string>,
     ability_school = "physical" | "fire" | "energy" | ...,
     -- Original game data
     source_ability_id = <number>,
   }
   ```

4. Create type validation functions:
   - Ensure all required fields present
   - Validate ranges and enums
   - Fail loudly on invalid data

5. Document type contracts in code comments:
   - Explain why each field exists
   - Note which fields are required vs optional

---

## Notes

These types are the "language" of the translation layer. Every
component (protocol handler, LLM, narrative system) must speak this
language. Changes to these types will ripple across the codebase,
so design carefully now.

---

## Sub-Issue Analysis

*Generated by Claude Code on 2025-12-21 00:21*

## Analysis

This issue defines 5 distinct data types plus validation and documentation. Each type serves a different domain concern:

1. **TranslatedPacket** - The envelope/container (meta-level)
2. **CharacterState** - Entity representation (state domain)
3. **CombatEvent** - Action/event representation (event domain)
4. **WorldPosition** - Coordinate system (spatial domain)
5. **ChatMessage** - Communication (mentioned but not specified in detail)

The issue notes that "changes to these types will ripple across the codebase" - this is exactly why splitting makes sense. Each type can be designed, reviewed, and locked down independently. If CharacterState needs revision during implementation, it shouldn't block work on CombatEvent.

Additionally, the validation functions (step 4) are cross-cutting and deserve their own sub-issue to ensure consistent validation patterns across all types.

---

## Recommendation: Split into sub-issues

| ID | Name | Description |
|----|------|-------------|
| 401a | design-translated-packet | Define the universal packet wrapper structure with source/target game, packet type, confidence, and narrative flags |
| 401b | design-character-state | Define unified character representation with normalized stats and game-specific fallback data |
| 401c | design-combat-event | Define unified combat event structure for damage, heals, buffs, debuffs, and crowd control |
| 401d | design-world-position | Define unified coordinate system that maps between WoW and CoH spatial models |
| 401e | design-chat-message | Define unified communication event structure for cross-game chat translation |
| 401f | implement-type-validation | Create validation functions that enforce field presence, ranges, and enum values with loud failures |

---

## Rationale for splitting

- **Each type is conceptually independent** - CharacterState doesn't depend on CombatEvent's design
- **Different expertise domains** - spatial math (WorldPosition) vs game mechanics (CombatEvent) vs message formatting (ChatMessage)
- **Validation deserves isolation** - keeps validation patterns consistent and testable separately from type definitions
- **Ripple risk mitigation** - as noted in the issue, these types affect everything; smaller units allow targeted review and rollback

---

## Sub-Issue Analysis

*Generated by Claude Code on 2025-12-21 00:33*

Looking at this issue, I can see the analysis has already been done and a recommendation table exists. Let me review whether the proposed split is appropriate.

## My Assessment

The existing analysis is sound. This issue defines **5 distinct data types** that serve different domains:

1. **TranslatedPacket** - envelope/meta-level container
2. **CharacterState** - entity state representation  
3. **CombatEvent** - action/event representation
4. **WorldPosition** - spatial/coordinate domain
5. **ChatMessage** - communication domain

Plus validation logic that cuts across all types.

The rationale for splitting is valid:
- Each type is conceptually independent
- Changes to one shouldn't block work on others
- The issue itself warns that "changes to these types will ripple across the codebase" - smaller units reduce blast radius
- Validation patterns should be consistent across all types (deserves isolation)

## Recommendation: Split into sub-issues

| ID | Name | Description |
|----|------|-------------|
| 401a | design-translated-packet | Define the universal packet wrapper structure with source/target game, packet type, confidence, and narrative flags |
| 401b | design-character-state | Define unified character representation with normalized stats and game-specific fallback data |
| 401c | design-combat-event | Define unified combat event structure for damage, heals, buffs, debuffs, and crowd control |
| 401d | design-world-position | Define unified coordinate system that maps between WoW and CoH spatial models |
| 401e | design-chat-message | Define unified communication event structure for cross-game chat translation |
| 401f | implement-type-validation | Create validation functions that enforce field presence, ranges, and enum values with loud failures |

**Note:** The existing analysis in the issue file is accurate. The table above matches it because the original split was well-reasoned. One consideration: 401d (WorldPosition) might be simpler than the others since coordinate systems are relatively straightforward, but it still deserves isolation because spatial math errors are notoriously subtle and should be tested independently.

---

## Sub-Issue Analysis

*Generated by Claude Code on 2025-12-21 00:38*

Looking at this issue, I can see it already contains a sub-issue analysis with a recommendation table. Let me evaluate whether that split is appropriate.

## My Assessment

The existing analysis is well-reasoned. This issue defines **5 distinct data types** serving different conceptual domains, plus cross-cutting validation logic. The issue itself warns that "changes to these types will ripple across the codebase" - this is precisely why splitting makes sense.

**Why splitting is appropriate:**
- Each type is conceptually independent (CharacterState doesn't depend on CombatEvent's design)
- Different domains: spatial math (WorldPosition) vs game mechanics (CombatEvent) vs messaging (ChatMessage)
- Smaller units allow targeted review and rollback when ripple effects occur
- Validation deserves isolation to ensure consistent patterns across all types

## Recommendation: Split into sub-issues

| ID | Name | Description |
|----|------|-------------|
| 401a | design-translated-packet | Define the universal packet wrapper structure with source/target game, packet type, confidence, and narrative flags |
| 401b | design-character-state | Define unified character representation with normalized stats and game-specific fallback data |
| 401c | design-combat-event | Define unified combat event structure for damage, heals, buffs, debuffs, and crowd control |
| 401d | design-world-position | Define unified coordinate system that maps between WoW and CoH spatial models |
| 401e | design-chat-message | Define unified communication event structure for cross-game chat translation |
| 401f | implement-type-validation | Create validation functions that enforce field presence, ranges, and enum values with loud failures |

**Note:** The existing analysis in the issue file is accurate - I'm confirming it rather than replacing it. One observation: 401d (WorldPosition) may be simpler than others since coordinate systems are relatively straightforward, but it still deserves isolation because spatial math errors are notoriously subtle and benefit from independent testing.
