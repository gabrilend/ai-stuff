#include "pch.h"
#include "sourceparser.h"
#include <cstdio>
#include "strutils.h"
#include <map>
#include <regex>

namespace fs = std::filesystem;

int gVerbose = 0;

typedef struct
{
    char optionName[128];
    int *pOption;
} OPTION_STRUCT;

OPTION_STRUCT gOptions[] = 
{
    {
        "Verbose",
        &gVerbose
    }
};

#define NUM_OPTIONS (sizeof(gOptions) / sizeof(gOptions[0]))

static char* RemoveTerminatingSeparator(char* dir)
{
    auto length = strlen(dir);
    if (length > 0 && (dir[length - 1] == '\\' || dir[length - 1] == '/'))
    {
        dir[length - 1] = 0;
    }
    return dir;
}

int ReadOptionsFromFile(Tokenizer *pTokenizer)
{
    Token token;
    enumTokenType eType;

    int iNumFound = 0;

    while ((eType = pTokenizer->GetNextToken(&token)) != TOKEN_NONE)
    {
        if (eType == TOKEN_IDENTIFIER)
        {
            int i;

            for (i=0; i < NUM_OPTIONS; i++)
            {
                if (strcmp(gOptions[i].optionName, token.sVal) == 0)
                {
                    pTokenizer->AssertNextTokenTypeAndGet(&token, TOKEN_RESERVEDWORD, RW_EQUALS, "Expected = after option name");
                    pTokenizer->AssertNextTokenTypeAndGet(&token, TOKEN_INT, 0, "Expected int after =");
                    *(gOptions[i].pOption) = token.iVal;

                    iNumFound++;
                }
            }
        }
    }

    return iNumFound;
}

void WriteOptionsFile(char *pFileName)
{
    int i;

    FILE *pOutFile = fopen_nofail(pFileName, "wt");

    fprintf(pOutFile, "//This file contains options for StructParser. It is autogenerated as new options occur.\n//The syntax is pretty self-explanatory\n//autogenerated" "nocheckin\n\n");

    for (i = 0; i < NUM_OPTIONS; i++)
    {
        fprintf(pOutFile, "%s = %d\n\n", gOptions[i].optionName, *(gOptions[i].pOption));
    }

    fclose(pOutFile);
}

void ProcessOptionFile(void)
{
    char exeName[MAX_PATH];
    char optionFileName[MAX_PATH];
    int iNumOptionsFound = 0;

    Tokenizer tokenizer;
    
    GetModuleFileNameA(NULL, exeName, MAX_PATH);

    TruncateStringAtLastOccurrence(exeName, '\\');

    sprintf(optionFileName, "%s\\%s", exeName, "structparser_settings.txt");

    if (tokenizer.LoadFromFile(optionFileName))
    {
        iNumOptionsFound = ReadOptionsFromFile(&tokenizer);
    }

    if (iNumOptionsFound != NUM_OPTIONS)
    {
        WriteOptionsFile(optionFileName);
    }
}

class CommandLineParser
{
public:
    CommandLineParser()
    {
        std::string cmdline{ ::GetCommandLineA() };
        std::regex r{ R"((\w+)\s*=\s*(?:(?:\"(.+?)\")|(.+?))(?:;|$))" };

        std::sregex_iterator const end;
        for (std::sregex_iterator it(cmdline.begin(), cmdline.end(), r); it != end; ++it)
        {
            // Group 2 is quoted, group 3 is unquoted
            auto kvit = args_.emplace(it->str(1), it->str((*it)[2].matched ? 2 : 3));
            if (kvit.first->second.empty())
            {
                throw std::invalid_argument(kvit.first->first);
            }
        }
    }

    std::string const& get(char const* name) const
    {
        auto it = args_.find(name);
        if (it == args_.end())
        {
            throw std::invalid_argument(name);
        }
        return it->second;
    }
    // Naming conventions are:
    //   Path:  Full relative or absolute name of a file such as ..\..\my.vcxproj
    //   Dir:   Relative or absolute location of  a directory in the file system
    fs::path getAsPath(char const* name) const
    {
        return { get(name) };
    }

    fs::path getAsAbsolutePath(char const* name) const
    {
        return fs::absolute(get(name));
    }

    fs::path getAsValidatedAbsolutePath(char const* name) const
    {
        auto path = getAsAbsolutePath(name);
        if (!fs::exists(path))
        {
            throw std::invalid_argument(name);
        }
        return path;
    }

    fs::path getAsDir(char const* name) const
    {
        auto val = get(name);
        if (val[val.length() - 1] == '\\')
        {
            return { val.begin(), val.end() - 1 };
        };
        return { val };
    }

    fs::path getAsAbsoluteDir(char const* name) const
    {
        return fs::absolute(getAsDir(name));
    }

    fs::path getAsValidatedAbsoluteDir(char const* name) const
    {
        auto path = getAsAbsoluteDir(name);
        if (!fs::exists(path))
        {
            throw std::invalid_argument(name);
        }
        return path;
    }


private:
    CommandLineParser(CommandLineParser const& other) = delete;
    CommandLineParser& operator = (CommandLineParser& other) = delete;

    struct CaseLess
    {
        struct Compare
        {
            bool operator() (unsigned char const& lhs, unsigned char const& rhs) const
            {
                return std::tolower(lhs) < std::tolower(rhs);
            }
        };

        bool operator() (std::string const& lhs, std::string const& rhs) const
        {
            return std::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end(), Compare());
        }
    };

    std::map<std::string, std::string, CaseLess> args_;
};

int main(int argc, char* argv[])
{
    try
    {
        ProcessOptionFile();
        CommandLineParser cmlLineParser;

        auto prjPath = cmlLineParser.getAsValidatedAbsolutePath("PrjPath");
        auto srcDir = cmlLineParser.getAsValidatedAbsoluteDir("SrcDir");
        auto commonDir = cmlLineParser.getAsValidatedAbsoluteDir("CommonDir");
        auto outDir = cmlLineParser.getAsAbsoluteDir("OutDir");
        auto intDir = cmlLineParser.getAsAbsoluteDir("IntDir");

        auto platform = cmlLineParser.get("Platform");
        auto configuration = cmlLineParser.get("Configuration");

        auto slnPath = cmlLineParser.getAsValidatedAbsolutePath("SlnPath");

        auto sourceParser = std::make_unique<SourceParser>(); // SourceParser is over a MB big so don't allocate it on the stack
        return sourceParser->ParseSource(prjPath, srcDir, commonDir, outDir, intDir, platform, configuration, slnPath);
    }
    catch (std::invalid_argument const& e)
    {
        printf("ERROR: Argument '%s' not found or not valid\n", e.what());
        printf("  A typical argument list from a custom build step looks like:\n"
            "     PrjPath=$(ProjectPath);\n"
            "     SrcDir=$(ProjectDir)..\\..\\src\\;\n"
            "     CommonDir=$(ProjectDir)..\\..\\..\\Common\\;\n"
            "     OutDir=$(OutDir);\n"
            "     IntDir=$(IntDir);\n"
            "     Platform=$(Platform);\n"
            "     Configuration=$(Configuration);\n"
            "     SlnPath=$(SolutionPath)\n");
    }
    catch (std::exception const& e)
    {
        printf("ERROR: %s", e.what());
    }
    return 1;
}