#!/bin/bash
# Unified .gitignore generation script for Delta-Version repository
# Generates a comprehensive, well-organized .gitignore file from pattern classification data

DIR="${DIR:-/mnt/mtwo/programming/ai-stuff/delta-version}"
ASSETS_DIR="${DIR}/assets"
PARENT_DIR="${DIR%/*}"
OUTPUT_FILE="${PARENT_DIR}/.gitignore"
CLASSIFICATION_FILE="${ASSETS_DIR}/pattern-classification.conf"

# Counters for reporting
declare -i total_patterns=0
declare -i security_patterns=0
declare -i os_patterns=0
declare -i ide_patterns=0
declare -i build_patterns=0
declare -i language_patterns=0
declare -i log_patterns=0
declare -i project_patterns=0

# -- {{{ backup_existing_gitignore
function backup_existing_gitignore() {
    local gitignore_path="$1"

    if [[ -f "$gitignore_path" ]]; then
        local backup_path="${gitignore_path}.backup.$(date +%Y%m%d_%H%M%S)"
        cp "$gitignore_path" "$backup_path"
        echo "Existing .gitignore backed up to: $backup_path"
        return 0
    fi
    return 1
}
# }}}

# -- {{{ write_header
function write_header() {
    local output="$1"

    cat >> "$output" <<'EOF'
# =============================================================================
# UNIFIED .gitignore for AI Projects Repository
# Auto-generated by Delta-Version Unification System
# =============================================================================
#
# This file consolidates gitignore patterns from all projects in the repository.
# Patterns are organized by category for easy maintenance.
#
EOF
    echo "# Generated: $(date '+%Y-%m-%d %H:%M:%S')" >> "$output"
    echo "# Source: Delta-Version pattern classification system" >> "$output"
    echo "#" >> "$output"
    echo "# To regenerate: scripts/generate-unified-gitignore.sh" >> "$output"
    echo "# =============================================================================" >> "$output"
    echo "" >> "$output"
}
# }}}

# -- {{{ write_section_header
function write_section_header() {
    local output="$1"
    local title="$2"
    local description="$3"

    echo "" >> "$output"
    echo "# =============================================================================" >> "$output"
    echo "# $title" >> "$output"
    echo "# =============================================================================" >> "$output"
    if [[ -n "$description" ]]; then
        echo "# $description" >> "$output"
    fi
    echo "" >> "$output"
}
# }}}

# -- {{{ write_security_section
function write_security_section() {
    local output="$1"

    write_section_header "$output" "SECURITY PATTERNS (Highest Priority)" "These patterns protect sensitive data and should NEVER be overridden"

    # Security patterns - manually curated for safety
    local patterns=(
        "*.key"
        "*.pem"
        "*.p12"
        "*.crt"
        ".env"
        ".env.*"
        ".env.local"
        ".secrets"
        "*_api_key*"
        "secrets/"
        ".aws/"
        ".ssh/"
    )

    for pattern in "${patterns[@]}"; do
        echo "$pattern" >> "$output"
        ((total_patterns++))
        ((security_patterns++))
    done
}
# }}}

# -- {{{ write_os_section
function write_os_section() {
    local output="$1"

    write_section_header "$output" "OPERATING SYSTEM FILES" "Cross-platform OS-generated files"

    # Read from classification file
    local in_section=false
    while IFS= read -r line; do
        if [[ "$line" == "[os_specific]" ]]; then
            in_section=true
            continue
        elif [[ "$line" =~ ^\[.*\]$ ]]; then
            in_section=false
        elif [[ "$in_section" == true && -n "$line" ]]; then
            echo "$line" >> "$output"
            ((total_patterns++))
            ((os_patterns++))
        fi
    done < "$CLASSIFICATION_FILE"

    # Add common OS patterns that might be missing
    local additional=(
        ".Spotlight-V100"
        ".Trashes"
        "._*"
        "ehthumbs.db"
    )

    for pattern in "${additional[@]}"; do
        if ! grep -q "^${pattern}$" "$output" 2>/dev/null; then
            echo "$pattern" >> "$output"
            ((total_patterns++))
            ((os_patterns++))
        fi
    done
}
# }}}

# -- {{{ write_ide_section
function write_ide_section() {
    local output="$1"

    write_section_header "$output" "IDE AND EDITOR FILES" "Development environment artifacts"

    # Read from classification file
    local in_section=false
    while IFS= read -r line; do
        if [[ "$line" == "[ide_files]" ]]; then
            in_section=true
            continue
        elif [[ "$line" =~ ^\[.*\]$ ]]; then
            in_section=false
        elif [[ "$in_section" == true && -n "$line" ]]; then
            echo "$line" >> "$output"
            ((total_patterns++))
            ((ide_patterns++))
        fi
    done < "$CLASSIFICATION_FILE"

    # Add common IDE patterns
    local additional=(
        ".vs/"
        "*.sublime-project"
        "*.sublime-workspace"
        "xcuserdata/"
        "DerivedData/"
        ".project"
        ".settings/"
        "*.iml"
    )

    for pattern in "${additional[@]}"; do
        if ! grep -q "^${pattern}$" "$output" 2>/dev/null; then
            echo "$pattern" >> "$output"
            ((total_patterns++))
            ((ide_patterns++))
        fi
    done
}
# }}}

# -- {{{ write_build_section
function write_build_section() {
    local output="$1"

    write_section_header "$output" "BUILD ARTIFACTS" "Compiled code and build system outputs"

    # Read from classification file
    local in_section=false
    while IFS= read -r line; do
        if [[ "$line" == "[build_artifacts]" ]]; then
            in_section=true
            continue
        elif [[ "$line" =~ ^\[.*\]$ ]]; then
            in_section=false
        elif [[ "$in_section" == true && -n "$line" ]]; then
            echo "$line" >> "$output"
            ((total_patterns++))
            ((build_patterns++))
        fi
    done < "$CLASSIFICATION_FILE"

    # Add common build patterns
    local additional=(
        "target/"
        "out/"
        "cmake-build-*/"
        "CMakeCache.txt"
        "CMakeFiles/"
        "compile_commands.json"
    )

    for pattern in "${additional[@]}"; do
        if ! grep -q "^${pattern}$" "$output" 2>/dev/null; then
            echo "$pattern" >> "$output"
            ((total_patterns++))
            ((build_patterns++))
        fi
    done
}
# }}}

# -- {{{ write_language_section
function write_language_section() {
    local output="$1"

    write_section_header "$output" "LANGUAGE-SPECIFIC PATTERNS" "Runtime artifacts and package manager files"

    # Read from classification file
    local in_section=false
    while IFS= read -r line; do
        if [[ "$line" == "[language_specific]" ]]; then
            in_section=true
            continue
        elif [[ "$line" =~ ^\[.*\]$ ]]; then
            in_section=false
        elif [[ "$in_section" == true && -n "$line" ]]; then
            echo "$line" >> "$output"
            ((total_patterns++))
            ((language_patterns++))
        fi
    done < "$CLASSIFICATION_FILE"

    # Add common language patterns
    local additional=(
        "node_modules/"
        "__pycache__/"
        "*.pyo"
        ".pytest_cache/"
        "*.class"
        "*.jar"
        "Cargo.lock"
        "zig-cache/"
        "zig-out/"
    )

    for pattern in "${additional[@]}"; do
        if ! grep -q "^${pattern}$" "$output" 2>/dev/null; then
            echo "$pattern" >> "$output"
            ((total_patterns++))
            ((language_patterns++))
        fi
    done
}
# }}}

# -- {{{ write_logs_section
function write_logs_section() {
    local output="$1"

    write_section_header "$output" "LOGS AND TEMPORARY FILES" "Runtime logs and temporary artifacts"

    # Read from classification file
    local in_section=false
    while IFS= read -r line; do
        if [[ "$line" == "[logs_temp]" ]]; then
            in_section=true
            continue
        elif [[ "$line" =~ ^\[.*\]$ ]]; then
            in_section=false
        elif [[ "$in_section" == true && -n "$line" ]]; then
            echo "$line" >> "$output"
            ((total_patterns++))
            ((log_patterns++))
        fi
    done < "$CLASSIFICATION_FILE"

    # Add common log patterns
    local additional=(
        "*.log.*"
        "logs/"
        "tmp/"
        "temp/"
        "*.cache"
        ".cache/"
    )

    for pattern in "${additional[@]}"; do
        if ! grep -q "^${pattern}$" "$output" 2>/dev/null; then
            echo "$pattern" >> "$output"
            ((total_patterns++))
            ((log_patterns++))
        fi
    done
}
# }}}

# -- {{{ write_project_specific_section
function write_project_specific_section() {
    local output="$1"

    write_section_header "$output" "PROJECT-SPECIFIC PATTERNS" "Custom patterns for individual projects (selected common patterns)"

    # Read selective project-specific patterns from classification
    # We'll include commonly useful ones, not all 700+
    local in_section=false
    local count=0
    local max_patterns=50  # Limit to prevent bloat

    while IFS= read -r line; do
        if [[ "$line" == "[project_specific]" ]]; then
            in_section=true
            continue
        elif [[ "$line" =~ ^\[.*\]$ ]]; then
            in_section=false
        elif [[ "$in_section" == true && -n "$line" && $count -lt $max_patterns ]]; then
            # Filter for commonly useful patterns
            case "$line" in
                # Include backup/cache patterns
                *.bak|*.backup|*.cache|*.temp)
                    echo "$line" >> "$output"
                    ((total_patterns++))
                    ((project_patterns++))
                    ((count++))
                    ;;
                # Include media files that shouldn't be tracked
                *.mp3|*.mp4|*.mkv|*.wav|*.avi|*.mov|*.flac)
                    echo "$line" >> "$output"
                    ((total_patterns++))
                    ((project_patterns++))
                    ((count++))
                    ;;
                # Include model files (AI projects)
                *.gguf|*.safetensors)
                    echo "$line" >> "$output"
                    ((total_patterns++))
                    ((project_patterns++))
                    ((count++))
                    ;;
                # Include test output
                test_output/|*_test)
                    echo "$line" >> "$output"
                    ((total_patterns++))
                    ((project_patterns++))
                    ((count++))
                    ;;
            esac
        fi
    done < "$CLASSIFICATION_FILE"
}
# }}}

# -- {{{ write_version_control_section
function write_version_control_section() {
    local output="$1"

    write_section_header "$output" "VERSION CONTROL" "Git-related patterns"

    echo "*.orig" >> "$output"
    echo "*.rej" >> "$output"
    echo "*.BACKUP.*" >> "$output"
    echo "*.BASE.*" >> "$output"
    echo "*.LOCAL.*" >> "$output"
    echo "*.REMOTE.*" >> "$output"

    ((total_patterns+=6))
}
# }}}

# -- {{{ write_footer
function write_footer() {
    local output="$1"

    echo "" >> "$output"
    echo "# =============================================================================" >> "$output"
    echo "# END OF UNIFIED .gitignore" >> "$output"
    echo "# =============================================================================" >> "$output"
    echo "# This file was auto-generated. Manual edits may be overwritten." >> "$output"
    echo "# To add project-specific patterns, consider using .gitignore files" >> "$output"
    echo "# in individual project directories." >> "$output"
    echo "# =============================================================================" >> "$output"
}
# }}}

# -- {{{ validate_gitignore
function validate_gitignore() {
    local gitignore_file="$1"
    local errors=0

    echo "Validating generated .gitignore..."

    # Check file exists and is readable
    if [[ ! -f "$gitignore_file" ]]; then
        echo "  ERROR: File not found"
        return 1
    fi

    # Check for empty file
    if [[ ! -s "$gitignore_file" ]]; then
        echo "  ERROR: File is empty"
        return 1
    fi

    # Check for syntax issues (basic validation)
    while IFS= read -r line; do
        # Skip comments and empty lines
        [[ "$line" =~ ^#.*$ || -z "$line" ]] && continue

        # Check for invalid characters
        if [[ "$line" =~ [[:cntrl:]] ]]; then
            echo "  WARNING: Line contains control characters: $line"
            ((errors++))
        fi
    done < "$gitignore_file"

    # Test with git check-ignore if available
    if command -v git &> /dev/null; then
        # Try a basic test
        if git check-ignore --no-index -q "test.o" 2>/dev/null; then
            echo "  Git check-ignore: Patterns appear functional"
        fi
    fi

    if [[ $errors -eq 0 ]]; then
        echo "  Validation: PASSED"
        return 0
    else
        echo "  Validation: $errors warning(s)"
        return 0  # Warnings don't fail validation
    fi
}
# }}}

# -- {{{ generate_report
function generate_report() {
    local output_file="$1"

    echo ""
    echo "========================================"
    echo "UNIFIED .gitignore GENERATION REPORT"
    echo "========================================"
    echo ""
    echo "Output file: $output_file"
    echo "File size:   $(wc -c < "$output_file") bytes"
    echo "Line count:  $(wc -l < "$output_file") lines"
    echo ""
    echo "Pattern Summary:"
    echo "  Security patterns:  $security_patterns"
    echo "  OS patterns:        $os_patterns"
    echo "  IDE patterns:       $ide_patterns"
    echo "  Build patterns:     $build_patterns"
    echo "  Language patterns:  $language_patterns"
    echo "  Log patterns:       $log_patterns"
    echo "  Project patterns:   $project_patterns"
    echo "  Version control:    6"
    echo "  ─────────────────────────"
    echo "  Total patterns:     $total_patterns"
    echo ""
}
# }}}

# -- {{{ generate_gitignore
function generate_gitignore() {
    local output_file="$1"

    echo "Generating unified .gitignore..."
    echo "Output: $output_file"
    echo ""

    # Check for classification file
    if [[ ! -f "$CLASSIFICATION_FILE" ]]; then
        echo "ERROR: Pattern classification file not found: $CLASSIFICATION_FILE"
        echo "Run analyze-gitignore.sh first to generate pattern data."
        return 1
    fi

    # Backup existing file
    backup_existing_gitignore "$output_file"

    # Create new file
    : > "$output_file"

    # Write sections
    write_header "$output_file"
    write_security_section "$output_file"
    write_os_section "$output_file"
    write_ide_section "$output_file"
    write_build_section "$output_file"
    write_language_section "$output_file"
    write_logs_section "$output_file"
    write_project_specific_section "$output_file"
    write_version_control_section "$output_file"
    write_footer "$output_file"

    # Validate
    validate_gitignore "$output_file"

    # Report
    generate_report "$output_file"

    echo "Generation complete!"
}
# }}}

# -- {{{ run_interactive_mode
function run_interactive_mode() {
    echo "=== Unified Gitignore Generator ==="
    echo ""
    echo "Current settings:"
    echo "  Classification file: $CLASSIFICATION_FILE"
    echo "  Output file:         $OUTPUT_FILE"
    echo ""
    echo "1. Generate unified .gitignore"
    echo "2. Preview (dry run)"
    echo "3. Change output location"
    echo "4. Validate existing .gitignore"
    echo "q. Quit"
    echo ""

    read -p "Select option: " choice

    case $choice in
        1)
            generate_gitignore "$OUTPUT_FILE"
            ;;
        2)
            local temp_file="/tmp/gitignore_preview_$$"
            generate_gitignore "$temp_file"
            echo ""
            echo "Preview of first 50 lines:"
            echo "─────────────────────────────"
            head -50 "$temp_file"
            echo "..."
            rm -f "$temp_file"
            ;;
        3)
            read -p "Enter new output path: " new_path
            if [[ -n "$new_path" ]]; then
                OUTPUT_FILE="$new_path"
                echo "Output path changed to: $OUTPUT_FILE"
            fi
            run_interactive_mode
            ;;
        4)
            if [[ -f "$OUTPUT_FILE" ]]; then
                validate_gitignore "$OUTPUT_FILE"
            else
                echo "No .gitignore file found at: $OUTPUT_FILE"
            fi
            ;;
        q|Q)
            echo "Exiting."
            exit 0
            ;;
        *)
            echo "Invalid selection"
            run_interactive_mode
            ;;
    esac
}
# }}}

# -- {{{ show_help
function show_help() {
    echo "Usage: generate-unified-gitignore.sh [OPTIONS]"
    echo ""
    echo "Generates a unified .gitignore file from pattern classification data."
    echo ""
    echo "Options:"
    echo "  -o, --output FILE   Output file path (default: parent dir .gitignore)"
    echo "  --dry-run           Preview without writing file"
    echo "  --validate          Validate existing .gitignore only"
    echo "  -I, --interactive   Run in interactive mode"
    echo "  --help              Show this help message"
    echo ""
    echo "Examples:"
    echo "  generate-unified-gitignore.sh                    # Generate to default location"
    echo "  generate-unified-gitignore.sh -o /path/.gitignore"
    echo "  generate-unified-gitignore.sh --dry-run"
    echo "  generate-unified-gitignore.sh -I"
}
# }}}

# -- {{{ main
function main() {
    local dry_run=false
    local validate_only=false

    while [[ $# -gt 0 ]]; do
        case $1 in
            -o|--output)
                OUTPUT_FILE="$2"
                shift 2
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --validate)
                validate_only=true
                shift
                ;;
            -I|--interactive)
                run_interactive_mode
                exit 0
                ;;
            --help)
                show_help
                exit 0
                ;;
            *)
                echo "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done

    if [[ "$validate_only" == true ]]; then
        if [[ -f "$OUTPUT_FILE" ]]; then
            validate_gitignore "$OUTPUT_FILE"
        else
            echo "No .gitignore file found at: $OUTPUT_FILE"
            exit 1
        fi
    elif [[ "$dry_run" == true ]]; then
        local temp_file="/tmp/gitignore_preview_$$"
        generate_gitignore "$temp_file"
        echo ""
        echo "Dry run complete. File not written to: $OUTPUT_FILE"
        rm -f "$temp_file"
    else
        generate_gitignore "$OUTPUT_FILE"
    fi
}
# }}}

# Run main if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
