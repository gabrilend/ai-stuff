# Issue 104: Parse war3map.wts (Trigger Strings)

**Phase:** 1 - Foundation
**Type:** Feature
**Priority:** High
**Dependencies:** 102-implement-mpq-archive-parser

---

## Current Behavior

Cannot read localized/dynamic strings. Trigger messages, ability tooltips,
and other text content reference string IDs that map to war3map.wts.

---

## Intended Behavior

A parser that extracts the string table from war3map.wts:
- Maps string IDs to content
- Handles multi-line strings
- Provides lookup function for other parsers
- Preserves formatting (color codes, newlines)

---

## Suggested Implementation Steps

1. **Create parser module**
   ```
   src/parsers/
   ├── w3i.lua          (from 103)
   └── wts.lua          (this issue)
   ```

2. **Understand wts format**
   ```
   // war3map.wts is a text file, not binary
   // Format:
   STRING <id>
   {
   <content>
   }

   // Example:
   STRING 1
   {
   Welcome to the map!
   }

   STRING 2
   {
   You have been defeated.
   Line two of the message.
   }
   ```

3. **Implement parser**
   ```lua
   function parse_wts(content)
       local strings = {}
       local pattern = "STRING%s+(%d+)%s*{([^}]*)}"

       for id, text in content:gmatch(pattern) do
           -- Trim leading/trailing whitespace from text
           text = text:gsub("^%s+", ""):gsub("%s+$", "")
           strings[tonumber(id)] = text
       end

       return strings
   end
   ```

4. **Handle edge cases**
   ```lua
   -- Handle strings with braces in content (escaped)
   -- Handle empty strings
   -- Handle very large string IDs
   -- Handle UTF-8 content
   ```

5. **Create lookup interface**
   ```lua
   local StringTable = {}
   StringTable.__index = StringTable

   function StringTable.new(wts_content)
       local self = setmetatable({}, StringTable)
       self.strings = parse_wts(wts_content)
       return self
   end

   function StringTable:get(id)
       return self.strings[id] or ""
   end

   function StringTable:resolve(text)
       -- Replace TRIGSTR_xxx references with actual strings
       return text:gsub("TRIGSTR_(%d+)", function(id)
           return self:get(tonumber(id))
       end)
   end

   return StringTable
   ```

6. **Handle TRIGSTR references**
   ```lua
   -- Other files reference strings as "TRIGSTR_001", "TRIGSTR_123", etc.
   -- The number maps to STRING <id> in wts

   function resolve_trigstr(text, string_table)
       return text:gsub("TRIGSTR_(%d+)", function(id)
           return string_table:get(tonumber(id))
       end)
   end
   ```

---

## Technical Notes

### Encoding

WC3 uses Windows-1252 encoding for older maps, UTF-8 for newer.
Consider detecting encoding or assuming UTF-8 with fallback.

### Color Codes

WC3 uses color codes like `|cffRRGGBB` and `|r` for reset:
```
|cffff0000Red Text|r Normal Text
```

Preserve these codes - they'll be interpreted by the renderer later.

### Newlines

WC3 uses `\r\n` (Windows) or just `\n`. Normalize to `\n` for consistency.

### Comment Lines

Some editors add comments starting with `//`. These should be ignored:
```
// This is a comment
STRING 1
{
Text content
}
```

---

## Related Documents

- docs/formats/wts-trigger-strings.md (to be created in 101)
- issues/102-implement-mpq-archive-parser.md (provides file access)
- issues/103-parse-war3map-w3i.md (may reference TRIGSTR in map name)

---

## Acceptance Criteria

- [ ] Can parse war3map.wts from test archives
- [ ] Correctly extracts all string IDs and content
- [ ] Handles multi-line strings
- [ ] Preserves color codes and formatting
- [ ] resolve() function replaces TRIGSTR references
- [ ] Handles empty/missing strings gracefully
- [ ] Unit tests for parser and resolver

---

## Notes

The wts parser is simple but critical - many other files reference
strings by TRIGSTR_xxx ID. Having a working string table early enables
testing of other parsers that need string resolution.

This is also a good test case for text file parsing (vs binary) since
wts is human-readable.

---

## Sub-Issue Analysis

*Generated by Claude Code on 2025-12-16 00:21*

## Analysis: Issue 104 - Parse war3map.wts

**Recommendation: Do NOT split this issue.**

### Rationale

This issue is already appropriately scoped for several reasons:

1. **Simple text format** - Unlike binary formats like MPQ or W3I, the WTS format is human-readable text with a straightforward structure (`STRING <id> { content }`). The parsing logic is fundamentally simple.

2. **Cohesive functionality** - The parser and the StringTable/resolver are tightly coupled. The resolver only makes sense with the parser, and testing one requires the other. Splitting them would create artificial boundaries.

3. **Small implementation footprint** - The entire implementation is approximately:
   - ~30 lines for the core parser
   - ~30 lines for the StringTable class
   - ~50 lines for edge case handling and tests
   
   This is a single-file, single-session implementation.

4. **No complex dependencies between parts** - Unlike issue 102 (MPQ) which has distinct phases (header parsing → hash tables → file extraction → compression), the WTS parser is essentially one operation with refinements.

5. **Linear workflow** - The implementation steps naturally flow together and share context. Switching between sub-issues would add overhead without benefit.

### If You Did Want to Split (Not Recommended)

For completeness, here's how it *could* be split, though I advise against it:

| ID | Name | Description | Dependencies |
|----|------|-------------|--------------|
| 104a | basic-wts-parser | Core STRING/content extraction | None |
| 104b | wts-edge-cases | Encoding, comments, escaped braces | 104a |
| 104c | trigstr-resolver | TRIGSTR_xxx replacement function | 104a |

But this creates 3 issues for what amounts to ~100 lines of code, which is excessive.

### Summary

Keep issue 104 as a single atomic issue. It's well-defined, appropriately sized (estimated 2-4 hours of work), and splitting it would add process overhead without improving manageability. The issue notes themselves acknowledge this: "The wts parser is simple but critical."
