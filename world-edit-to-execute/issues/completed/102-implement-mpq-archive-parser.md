# Issue 102: Implement MPQ Archive Parser

**Phase:** 1 - Foundation
**Type:** Feature (Core Infrastructure)
**Priority:** Critical
**Dependencies:** 101-research-wc3-file-formats

---

## Current Behavior

No ability to read .w3m or .w3x files. These are MPQ archives containing all map data.
Without an MPQ parser, no map content can be accessed.

---

## Intended Behavior

A Lua module that can:
- Open .w3m/.w3x files (MPQ archives)
- List all files contained within the archive
- Extract individual files by name
- Handle all compression formats used by WC3 maps
- Provide a clean API for other modules to access map contents

---

## Sub-Issues

This issue is complex and broken into sub-issues:

| Sub-Issue | Description | Status |
|-----------|-------------|--------|
| 102a | Parse MPQ header structure | **Completed** |
| 102b | Parse MPQ hash table | **Completed** |
| 102c | Parse MPQ block table | **Completed** |
| 102d | Implement file extraction with decompression | **Completed** |

Complete sub-issues in order (a → b → c → d).

---

## Suggested Implementation Steps

1. Create `src/mpq/` module directory
2. Implement header parser (102a)
3. Implement hash table parser (102b)
4. Implement block table parser (102c)
5. Implement file extraction (102d)
6. Create unified `mpq.lua` API module
7. Write unit tests for each component

---

## API Design (Proposed)

```lua
local mpq = require("src.mpq")

-- Open an archive
local archive, err = mpq.open("/path/to/map.w3x")
if not archive then
    error("Failed to open: " .. err)
end

-- List files
local files = archive:list()
for _, filename in ipairs(files) do
    print(filename)
end

-- Check if file exists
if archive:has("war3map.w3i") then
    -- Extract file contents
    local data = archive:extract("war3map.w3i")
end

-- Close archive
archive:close()
```

---

## Technical Considerations

### Decision: Library vs. Custom Implementation

**Option A: Use StormLib via FFI**
- Pros: Battle-tested, handles all edge cases, maintained
- Cons: External dependency, C library FFI complexity, licensing (MIT)

**Option B: Pure Lua Implementation**
- Pros: No dependencies, educational value, full control
- Cons: More work, potential edge cases, compression library needs

**Recommendation:** Start with pure Lua for header/tables, use existing Lua libraries
for compression (lua-zlib, lua-bzip2). Consider StormLib fallback if edge cases arise.

### Compression Formats

WC3 maps may use:
- No compression (raw)
- PKWARE DCL (implode)
- zlib (deflate)
- bzip2

Need Lua bindings or pure implementations for each.

---

## Related Documents

- docs/formats/mpq-archive.md (format specification)
- issues/102a-parse-mpq-header.md
- issues/102b-parse-mpq-hash-table.md
- issues/102c-parse-mpq-block-table.md
- issues/102d-implement-file-extraction.md

## Test Files

- assets/DAoW-2.1.w3x
- assets/DAoW-5.4c-PUBLIC-TEST-OCTOBER.w3x
- (any .w3x in assets/)

---

## Acceptance Criteria

- [x] Can open any .w3x file in assets/ without error (15/16, 1 uses unsupported PKWARE DCL)
- [x] Can list all files in an archive (via listfile if present)
- [x] Can extract war3map.w3i from test archives
- [x] Can extract war3map.j (JASS script) from test archives (when present)
- [x] Handles both compressed and uncompressed files
- [x] Clean error messages for corrupt/invalid archives
- [x] Unit tests pass for all components

---

## Notes

This is the foundational module - everything else depends on it. Take time to get
the API right, as many other modules will depend on it.

Consider memory efficiency for large archives. Streaming extraction may be needed
for very large embedded files.

---

## Structure Review

*Generated by Claude Code on 2025-12-16 00:24*

The analysis file exists but is empty. Let me provide my structural review:

---

## Structural Review: Issue 102 MPQ Archive Parser

### 1. Sub-Issues That Should Be Broken Down Further

**102b - Parse MPQ Hash Table** → Split into 2 sub-issues

This issue conflates two distinct concerns:
- **102b1 - Implement MPQ Crypto Table and Hash Functions**: The crypto table generation and three hash function types are foundational utilities used by multiple components (hash table decryption, block table decryption, file encryption keys). This is a standalone module.
- **102b2 - Parse and Query Hash Table**: The actual hash table parsing, decryption, and lookup logic.

*Rationale*: The hash/crypto module is a dependency of 102b, 102c, AND 102d. Extracting it makes dependencies cleaner and allows independent testing of the cryptographic primitives.

---

**102d - Implement File Extraction** → Split into 3 sub-issues

This issue is overloaded with multiple complex responsibilities:
- **102d1 - Implement Decompression Support**: Set up zlib, bzip2, PKWARE DCL decompression. Handle multi-compression byte flags. This is pure library integration with no MPQ-specific logic.
- **102d2 - Implement Sector Reading and Decryption**: Read sector offset tables, handle single-unit vs multi-sector files, decrypt encrypted sectors.
- **102d3 - Implement File Extraction API**: Tie together lookup, sector reading, decryption, and decompression into the final `extract()` function.

*Rationale*: Decompression setup is significant work (especially PKWARE DCL which may need custom implementation). Sector handling is tricky. Combining all three makes 102d too large to implement in one focused session.

---

### 2. Missing Sub-Issues (Gaps)

**102e - Implement Archive File Listing** (NEW)

The root issue's acceptance criteria includes "Can list all files in an archive" but no sub-issue covers this. MPQ archives don't have a directory - file listing requires:
- Parsing `(listfile)` if present (a text file inside the archive listing known filenames)
- Fallback: return "cannot list files, listfile not present"

This is distinct from extraction and should be its own issue.

---

**102f - Create Unified MPQ API Module** (NEW)

The root issue mentions "Create unified `mpq.lua` API module" in step 6, but this isn't captured in a sub-issue. This includes:
- The `mpq.open()` function
- The archive object with `:list()`, `:has()`, `:extract()`, `:close()` methods
- Error handling and resource cleanup

This is the integration point that ties all sub-modules together.

---

**102g - MPQ Parser Integration Tests** (NEW)

The acceptance criteria list 7 items that require end-to-end testing against real archives. Unit tests in each sub-issue test components in isolation; integration tests verify the complete workflow.

---

### 3. Structural Improvements

**Revised Sub-Issue Organization**

| ID | Description | Dependencies |
|----|-------------|--------------|
| 102a | Parse MPQ header structure | - |
| 102b1 | Implement crypto table and hash functions | - |
| 102b2 | Parse and query hash table | 102a, 102b1 |
| 102c | Parse block table | 102a, 102b1 |
| 102d1 | Implement decompression support | - |
| 102d2 | Implement sector reading and decryption | 102b1, 102c |
| 102d3 | Implement file extraction function | 102b2, 102d1, 102d2 |
| 102e | Implement archive file listing | 102d3 |
| 102f | Create unified MPQ API module | 102a-102e |
| 102g | Integration tests with real archives | 102f |

**Suggested Execution Order**:
```
102a ─────────────────┐
                      ├─→ 102b2 ─┐
102b1 ─┬─→ 102c ─┐    │          │
       │         ├────┴─→ 102d2 ─┼─→ 102d3 ─→ 102e ─→ 102f ─→ 102g
       │         │               │
102d1 ─┴─────────┴───────────────┘
```

Note: 102a, 102b1, and 102d1 can be worked in parallel (no interdependencies).

---

### Summary of Recommendations

| Action | Issue | Recommendation |
|--------|-------|----------------|
| Split | 102b | Extract crypto/hash module as 102b1, rename remainder 102b2 |
| Split | 102d | Split into 102d1 (decompression), 102d2 (sectors), 102d3 (extraction) |
| Add | 102e | File listing via `(listfile)` |
| Add | 102f | Unified API module creation |
| Add | 102g | Integration tests against real .w3x files |
| Update | 102 | Revise sub-issue table and dependency graph |

---

## Implementation Notes

*Completed 2025-12-16*

### What Was Built

Created unified MPQ API in `src/mpq/init.lua` that ties together all sub-modules:

```lua
local mpq = require("mpq")
local archive = mpq.open("map.w3x")

-- Query archive
archive:info()           -- Archive metadata
archive:has("filename")  -- Check file existence
archive:file_count()     -- Number of files

-- Extract files
archive:extract("war3map.w3i")           -- Returns file data
archive:extract_to_file("file", "out")   -- Write to disk

-- List files (requires listfile)
archive:list()

-- Cleanup
archive:close()
```

### Test Results

- **15/16 test maps** open and extract war3map.w3i successfully
- 1 map (Daow6.2.w3x) uses PKWARE DCL compression (not implemented)
- All unit tests pass

### Module Dependencies

```
src/mpq/init.lua (unified API)
├── mpq/header.lua     (HM3W + MPQ header parsing)
├── mpq/hashtable.lua  (hash table parsing and lookup)
├── mpq/blocktable.lua (block table parsing)
├── mpq/extract.lua    (file extraction + decompression)
└── mpq/hash.lua       (crypto tables, hashing, decryption)
```

### Known Limitations

1. PKWARE DCL compression not implemented (affects 1/16 test maps)
2. Requires Lua 5.3+ for bitwise operators
3. Uses Python3 zlib for decompression (temporary)
4. Entire archive loaded into memory (fine for WC3 map sizes)
