#!/bin/bash
# test_002d_parallel_processing.sh
# Tests the parallel_process_issues orchestrator from issue 002d.
# Uses mock claude command and temporary test issues.
#
# Usage: ./test_002d_parallel_processing.sh

set -euo pipefail

DIR="/mnt/mtwo/programming/ai-stuff/world-edit-to-execute"
TEST_DIR=""

# Queue variables
QUEUE_DIR=""
QUEUE_COUNTER=0
STREAM_INDEX=0
STREAMER_PID=""
PARALLEL_COUNT=2
STREAM_DELAY=0
SKIP_EXISTING=false
ARCHIVE_MODE=false
ARCHIVE_DIR=""
declare -a ROOTS_WITH_SUBS=()

# {{{ setup_test
setup_test() {
    TEST_DIR=$(mktemp -d)
    ARCHIVE_DIR="$TEST_DIR/analysis"
    mkdir -p "$TEST_DIR/issues"
}
# }}}

# {{{ cleanup_test
cleanup_test() {
    if [[ -n "$STREAMER_PID" ]]; then
        kill "$STREAMER_PID" 2>/dev/null || true
        wait "$STREAMER_PID" 2>/dev/null || true
        STREAMER_PID=""
    fi
    if [[ -n "$QUEUE_DIR" ]] && [[ -d "$QUEUE_DIR" ]]; then
        rm -rf "$QUEUE_DIR"
        QUEUE_DIR=""
    fi
    if [[ -n "$TEST_DIR" ]] && [[ -d "$TEST_DIR" ]]; then
        rm -rf "$TEST_DIR"
        TEST_DIR=""
    fi
    ROOTS_WITH_SUBS=()
}
# }}}

trap cleanup_test EXIT INT TERM

# {{{ setup_queue
setup_queue() {
    QUEUE_DIR=$(mktemp -d)
    QUEUE_COUNTER=0
    STREAM_INDEX=0
    STREAMER_PID=""
}
# }}}

# Mock claude - simulates delay and returns test response
claude() {
    sleep 0.1  # Simulate API call
    echo "Mock analysis for: $2"
}
export -f claude

# {{{ is_subissue
is_subissue() {
    local filename="$1"
    [[ "$filename" =~ ^[0-9]+[a-z]- ]]
}
# }}}

# {{{ get_root_id
get_root_id() {
    local filename="$1"
    echo "$filename" | grep -oE '^[0-9]+' | head -1
}
# }}}

# {{{ has_subissues
has_subissues() {
    local root_id="$1"
    local count
    count=$(find "$TEST_DIR/issues" -maxdepth 1 -name "${root_id}[a-z]-*.md" -type f 2>/dev/null | wc -l)
    [[ $count -gt 0 ]]
}
# }}}

# {{{ has_subissue_analysis
has_subissue_analysis() {
    local file="$1"
    grep -qE "^## Sub-Issue Analysis$" "$file" 2>/dev/null
}
# }}}

# {{{ has_initial_analysis
has_initial_analysis() {
    local file="$1"
    grep -qE "^## Initial Analysis$" "$file" 2>/dev/null
}
# }}}

# {{{ build_prompt
build_prompt() {
    echo "Analyze issue: $1"
}
# }}}

# {{{ stream_queue
stream_queue() {
    local done_file="$QUEUE_DIR/done"
    local stream_idx=0
    local idle_count=0
    local max_idle=10

    while true; do
        local ready_file="$QUEUE_DIR/${stream_idx}.ready"
        if [[ -f "$ready_file" ]]; then
            idle_count=0
            ((++stream_idx))
            sleep "${STREAM_DELAY:-0}"
        else
            if [[ -f "$done_file" ]]; then
                ((++idle_count))
                if [[ $idle_count -ge $max_idle ]]; then
                    break
                fi
            fi
            sleep 0.1
        fi
    done
}
# }}}

# {{{ process_issue_parallel
process_issue_parallel() {
    local issue_path="$1"
    local prompt="$2"
    local queue_num=$((QUEUE_COUNTER++))
    local output_file="$QUEUE_DIR/${queue_num}.output"
    local meta_file="$QUEUE_DIR/${queue_num}.meta"
    local basename
    basename=$(basename "$issue_path")

    echo "$issue_path" > "$meta_file"

    # Mock claude inline (no timeout for testing)
    local response=""
    sleep 0.1
    response="Mock analysis for: $prompt"
    echo "$response" > "$output_file"
    echo "success" >> "$meta_file"
    {
        echo ""
        echo "---"
        echo ""
        echo "## Sub-Issue Analysis"
        echo ""
        echo "*Generated by test*"
        echo ""
        echo "$response"
    } >> "$issue_path"

    touch "$QUEUE_DIR/${queue_num}.ready"
}
# }}}

# {{{ parallel_process_issues
parallel_process_issues() {
    local issues=("$@")
    local max_parallel="${PARALLEL_COUNT:-3}"
    local running=0
    local pids=()

    setup_queue

    stream_queue &
    STREAMER_PID=$!

    for issue in "${issues[@]}"; do
        local basename
        basename=$(basename "$issue")
        local root_id
        root_id=$(get_root_id "$basename")

        if is_subissue "$basename"; then
            continue
        fi

        if has_subissues "$root_id"; then
            ROOTS_WITH_SUBS+=("$issue")
            continue
        fi

        if [[ "$SKIP_EXISTING" == true ]]; then
            if has_subissue_analysis "$issue" || has_initial_analysis "$issue"; then
                continue
            fi
        fi

        while (( running >= max_parallel )); do
            wait -n 2>/dev/null || true
            ((--running)) || true
        done

        (
            local prompt
            prompt=$(build_prompt "$issue")
            process_issue_parallel "$issue" "$prompt"
        ) &
        pids+=($!)
        ((++running))
    done

    for pid in "${pids[@]}"; do
        wait "$pid" 2>/dev/null || true
    done

    touch "$QUEUE_DIR/done"
    wait "$STREAMER_PID" 2>/dev/null || true
}
# }}}

# {{{ create_test_issue
create_test_issue() {
    local name="$1"
    local file="$TEST_DIR/issues/$name"
    cat > "$file" << EOF
# Test Issue: $name

Test content
EOF
    echo "$file"
}
# }}}

# {{{ test_processes_issues
test_processes_issues() {
    echo "=== Test: parallel_process_issues processes issues ==="
    setup_test

    local issue1 issue2 issue3
    issue1=$(create_test_issue "101-first.md")
    issue2=$(create_test_issue "102-second.md")
    issue3=$(create_test_issue "103-third.md")

    parallel_process_issues "$issue1" "$issue2" "$issue3"

    # Check all issues have analysis appended
    local count=0
    for issue in "$issue1" "$issue2" "$issue3"; do
        if has_subissue_analysis "$issue"; then
            ((++count))
        fi
    done

    if [[ $count -eq 3 ]]; then
        echo "PASS: all issues processed"
    else
        echo "FAIL: only $count/3 issues processed"
        return 1
    fi

    cleanup_test
}
# }}}

# {{{ test_skips_subissues
test_skips_subissues() {
    echo "=== Test: skips sub-issues ==="
    setup_test

    # Create a standalone sub-issue (no root) - should be skipped
    # Create a normal root issue - should be processed
    local normal sub
    normal=$(create_test_issue "102-normal.md")
    sub=$(create_test_issue "103a-orphan-subissue.md")

    parallel_process_issues "$normal" "$sub"

    if has_subissue_analysis "$normal" && ! has_subissue_analysis "$sub"; then
        echo "PASS: skipped sub-issue"
    else
        echo "FAIL: sub-issue was processed or normal issue wasn't"
        return 1
    fi

    cleanup_test
}
# }}}

# {{{ test_tracks_roots_with_subs
test_tracks_roots_with_subs() {
    echo "=== Test: tracks roots with existing sub-issues ==="
    setup_test

    local root
    root=$(create_test_issue "101-root.md")
    create_test_issue "101a-existing-sub.md" >/dev/null

    ROOTS_WITH_SUBS=()
    parallel_process_issues "$root"

    if [[ ${#ROOTS_WITH_SUBS[@]} -eq 1 ]]; then
        echo "PASS: tracked root with sub-issues"
    else
        echo "FAIL: ROOTS_WITH_SUBS has ${#ROOTS_WITH_SUBS[@]} items"
        return 1
    fi

    cleanup_test
}
# }}}

# {{{ test_respects_parallel_count
test_respects_parallel_count() {
    echo "=== Test: respects PARALLEL_COUNT ==="
    setup_test

    PARALLEL_COUNT=1  # Force sequential

    local issue1 issue2
    issue1=$(create_test_issue "101-first.md")
    issue2=$(create_test_issue "102-second.md")

    local start_time end_time
    start_time=$(date +%s.%N)
    parallel_process_issues "$issue1" "$issue2"
    end_time=$(date +%s.%N)

    # With PARALLEL_COUNT=1, should take at least 0.2s (2 x 0.1s mock delay)
    # This is a weak test but validates the function runs
    if has_subissue_analysis "$issue1" && has_subissue_analysis "$issue2"; then
        echo "PASS: respects parallel count"
    else
        echo "FAIL: issues not processed"
        return 1
    fi

    PARALLEL_COUNT=2
    cleanup_test
}
# }}}

# {{{ main
main() {
    echo "Testing Issue 002d: Parallel Processing Loop"
    echo "============================================="
    echo ""

    local failed=0

    test_processes_issues || ((failed++))
    test_skips_subissues || ((failed++))
    test_tracks_roots_with_subs || ((failed++))
    test_respects_parallel_count || ((failed++))

    echo ""
    echo "============================================="
    if [[ $failed -eq 0 ]]; then
        echo "All tests passed!"
        exit 0
    else
        echo "$failed test(s) failed"
        exit 1
    fi
}
# }}}

main "$@"
